# Assignment-5_Quicksort-Algorithm

## Running the Code
Two Python files are provided to implementation each version of Quicksort as deterministic and randomized. The files are in Python and do not have any dependencies besides the standard Python interpreter.
To execute the deterministic Quicksort, enter the file called Quick sort Implementation.py in a Python environment or terminal and run the script. The sorting algorithm in the code will use a fixed pivot algorithm where the end of the array, the last element of the array will be employed as the pivot in every recursive call.
Open the file named Randomized Quick sort.py and also execute the script in the same way to run the randomized Quicksort. In this form, a random pivot is chosen at each step, lowering the chances of low performance on sorted or reverse-sorted input arrays.
Sample arrays have been added to each script and the original and sorted array will be printed after running the program. The two programs exhibit recursiveness, and their output can be consumable in terms of performance comparison as well as in treating algorithm flow.

## Summary of Findings
Deterministic Quicksort algorithm has a fixed pivot strategy, usually the right-most element of the subarray. This style of implementation is efficient on randomly ordered input, and has average-case time complexity n log n. But when the input array is sorted or in reverse order the algorithm will be disadvantaged in this case, as the partitions used are unbalanced; many times the worst-case time complexity becomes n squared. The behavior has manifested in the empirical testing where large decreases in performance were recorded in using deterministic version in such cases.
The randomized variation of Quicksort is more robust, in contrast, by choosing a random pivot at each level of the recursive partition. This prohibits the stable construction of biased subarrays and enables the algorithm to have the same average-case time complexity on any kind of input data, sorted and reverse-sorted sequences included. The results were consistent across all the empirical studies performed, which also confirmed the theoretically retrieved fact that randomized Quicksort successfully reduces the risk of the worst-case behavior.
The analysis came to the conclusion that deterministic Quicksort is efficient on random inputs but not necessarily reliable under all circumstances. Indeed, Randomized Quicksort has predictable and scalable performance on a variety of input, rendering it more appropriate to real-world situations when the character of the inputs is not known in advance. The comparison highlights the importance of pivot choice in the design of algorithms and points out the strength of randomization to promote the average-case performance.

